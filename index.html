<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Knight Adventure – Hollow 256x256</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body { width:100%; height:100%; overflow:hidden; background:#0A0A1F; font-family:'Courier New', monospace; }
canvas { display:block; image-rendering: pixelated; }
#controls { position:absolute; bottom:10px; width:100%; text-align:center; z-index:10; }
.btn { background:rgba(0,0,0,0.6); color:white; font-size:28px; border:none; padding:15px 20px; margin:5px; border-radius:12px; cursor:pointer; touch-action:manipulation; }
.btn:active { background: rgba(0,0,0,0.8); }
#menu { position:absolute; top:0; left:0; width:100%; height:100%; background:#0A0A1F; display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:20; }
#menu h1 { color:#FFFFFF; font-family:'Courier New',monospace; font-size:96px; margin-bottom:40px; text-align:center; text-shadow: 3px 3px 7px #000; }
#startBtn { font-size:40px; padding:30px 60px; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="menu">
    <h1>Pixel Knight Adventure</h1>
    <button id="startBtn" class="btn">Iniciar</button>
</div>

<div id="controls">
<button class="btn" id="leftBtn">⏪</button>
<button class="btn" id="jumpBtn">⏫</button>
<button class="btn" id="attackBtn">⚔️</button>
<button class="btn" id="rightBtn">⏩</button>
</div>

<script>
// ===================== CONFIGURAÇÃO =====================
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let groundLevel;
function resizeCanvas(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    groundLevel = canvas.height - 300; // player maior
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// CONTROLES
let keys = {left:false, right:false, up:false, attack:false};
const buttons = {left:"leftBtn", right:"rightBtn", up:"jumpBtn", attack:"attackBtn"};
Object.keys(buttons).forEach(k=>{
    const el = document.getElementById(buttons[k]);
    el.addEventListener("touchstart", e=>{ e.preventDefault(); keys[k]=true; });
    el.addEventListener("touchend", e=>{ e.preventDefault(); keys[k]=false; });
});
document.addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft") keys.left=true;
    if(e.key==="ArrowRight") keys.right=true;
    if(e.key==="ArrowUp" || e.code==="Space") keys.up=true;
    if(e.key==="z" || e.key==="Z") keys.attack=true;
    if(e.key==="Enter" && gameOver) resetGame();
});
document.addEventListener("keyup", e=>{
    if(e.key==="ArrowLeft") keys.left=false;
    if(e.key==="ArrowRight") keys.right=false;
    if(e.key==="ArrowUp" || e.code==="Space") keys.up=false;
    if(e.key==="z" || e.key==="Z") keys.attack=false;
});

let cameraX = 0;
let gameOver = false;
let gameStarted = false;
let currentPhase = 1;

// ===================== MENU =====================
const menu = document.getElementById("menu");
const startBtn = document.getElementById("startBtn");
startBtn.addEventListener("click", () => {
    gameStarted = true;
    menu.style.display = "none";
});
canvas.addEventListener("touchstart", () => {
    if(!gameStarted){
        gameStarted = true;
        menu.style.display = "none";
    } else if(gameOver){
        resetGame();
    }
});

// ===================== PARTICULAS =====================
class Particle{
    constructor(x,y,color,size=8){
        this.x = x; this.y = y;
        this.vx = (Math.random()-0.5)*6;
        this.vy = Math.random()*-4-2;
        this.alpha = 1;
        this.color = color;
        this.size = size;
    }
    update(){ this.x+=this.vx; this.y+=this.vy; this.alpha-=0.03; }
    draw(){
        ctx.globalAlpha=this.alpha;
        ctx.fillStyle=this.color;
        ctx.fillRect(this.x-cameraX,this.y,this.size,this.size);
        ctx.globalAlpha=1;
    }
}

// ===================== PLAYER 256x256 =====================
class Player{
    constructor(){
        this.w=256; this.h=256;
        this.x=400; this.y=groundLevel-this.h;
        this.velY=0; this.speed=8;
        this.lives=5; this.score=0;
        this.onGround=true; this.frame=0;
        this.attackCooldown=0;
        this.attackFrame=0;
    }
    update(){
        if(keys.left) this.x-=this.speed;
        if(keys.right) this.x+=this.speed;
        this.velY+=1.2;
        this.y+=this.velY;
        if(this.y+this.h>=groundLevel){
            this.y=groundLevel-this.h;
            this.velY=0;
            this.onGround=true;
        }
        if(keys.up && this.onGround){
            this.velY=-24;
            this.onGround=false;
        }
        if(keys.left || keys.right){ this.frame+=0.2; if(this.frame>3) this.frame=0; } 
        else this.frame=0;
        if(this.attackCooldown>0){ 
            this.attackCooldown--; 
            this.attackFrame+=0.5;
            if(this.attackFrame>4) this.attackFrame=0;
        }
    }
    attack(){ if(this.attackCooldown===0){ this.attackCooldown=30; this.attackFrame=0; return true;} return false;}
    draw(){
        // sombra
        ctx.fillStyle="rgba(0,0,0,0.2)";
        ctx.fillRect(this.x-cameraX+64,this.y+this.h-32,128,16);

        // corpo detalhado
        ctx.fillStyle="#EEEEEE";
        ctx.fillRect(this.x-cameraX+64,this.y+96,128,128); // tronco
        ctx.fillRect(this.x-cameraX+48,this.y+64,160,32);  // ombros

        // cabeça
        ctx.fillStyle="#FFFFFF";
        ctx.fillRect(this.x-cameraX+80,this.y,96,64);

        // olhos
        ctx.fillStyle="#000000";
        ctx.fillRect(this.x-cameraX+104,this.y+16,16,16);
        ctx.fillRect(this.x-cameraX+136,this.y+16,16,16);

        // espada
        if(keys.attack || this.attackCooldown>0){ 
            ctx.fillStyle="#FFFFFF";
            let swing = Math.sin(this.attackFrame)*32;
            ctx.fillRect(this.x-cameraX+192+swing,this.y+128,32,16);
        }
    }
}

// ===================== INIMIGOS 256x256 =====================
class Enemy{
    constructor(x,type=0){
        this.x=x;
        this.y=groundLevel-256;
        this.size=256;
        this.speed=2;
        this.direction=Math.random()<0.5?-1:1;
        this.alive=true;
        this.type=type;
    }
    update(){ 
        this.x+=this.speed*this.direction; 
        if(this.x<cameraX-300) this.direction=1; 
        if(this.x>cameraX+canvas.width+300) this.direction=-1;
    }
    draw(){
        if(!this.alive) return;
        ctx.fillStyle="rgba(0,0,0,0.2)";
        ctx.fillRect(this.x-cameraX+64,this.y+this.size-32,128,16);
        ctx.fillStyle=this.type==0?"#AAAAAA":"#CCCCCC";
        ctx.fillRect(this.x-cameraX+64,this.y+64,128,128);
        ctx.fillStyle="#000000";
        ctx.fillRect(this.x-cameraX+88,this.y+88,32,32);
        ctx.fillRect(this.x-cameraX+136,this.y+88,32,32);
    }
}

// ===================== BACKGROUND =====================
class Background{
    constructor(x,y,width,height,color,layer,type="pillar"){
        this.x=x; this.y=y; this.width=width; this.height=height; 
        this.color=color; this.layer=layer; this.type=type;
        this.offset = Math.random()*Math.PI*2;
    }
    update(){ 
        this.x -= 1*this.layer; 
        if(this.x+this.width<cameraX) this.x=cameraX+canvas.width+500; 
        this.offset += 0.01;
    }
    draw(){
        if(this.type==="pillar"){
            ctx.fillStyle=this.color;
            ctx.fillRect(this.x-cameraX*this.layer,this.y,this.width,this.height);
            ctx.fillStyle="rgba(255,255,255,0.05)";
            ctx.fillRect(this.x-cameraX*this.layer,this.y, this.width,32);
        }
    }
}

// ===================== LUA E ESTRELAS =====================
let stars = [];
for(let i=0;i<100;i++){ stars.push({x:Math.random()*4000, y:Math.random()*200, alpha: Math.random()}); }

function drawMoon(){
    let moonX = canvas.width-300-cameraX*0.1;
    let moonY = 150;
    let gradient = ctx.createRadialGradient(moonX,moonY,50,moonX,moonY,150);
    gradient.addColorStop(0,"rgba(255,255,255,0.9)");
    gradient.addColorStop(1,"rgba(255,255,255,0)");
    ctx.fillStyle=gradient; 
    ctx.beginPath(); 
    ctx.arc(moonX,moonY,150,0,Math.PI*2); 
    ctx.fill();
    stars.forEach(s=>{
        ctx.fillStyle = `rgba(255,255,255,${0.3+0.7*Math.sin(Date.now()/1000 + s.x)})`;
        ctx.fillRect(s.x-cameraX*0.05, s.y, 4,4);
    });
}

// ===================== OBJETOS =====================
let player = new Player();
let enemies = [new Enemy(800,0), new Enemy(1600,1)];
let backgrounds = [
    new Background(200,groundLevel-512,128,512,"#222222",0.2,"pillar"),
    new Background(600,groundLevel-640,160,640,"#333333",0.3,"pillar"),
    new Background(1200,groundLevel-512,128,512,"#444444",0.25,"pillar"),
    new Background(1800,groundLevel-640,160,640,"#222222",0.15,"pillar")
];
let particles = [];

// ===================== SPAWN =====================
function autoSpawnEnemies(){
    let maxEnemiesOnScreen = 3;
    let farthestX = enemies.length ? Math.max(...enemies.map(e => e.x)) : cameraX + canvas.width;
    while(enemies.length < maxEnemiesOnScreen || farthestX < cameraX + canvas.width + 500){
        let newX = farthestX + Math.random() * 800 + 400;
        let type = Math.random()<0.5?0:1;
        enemies.push(new Enemy(newX,type));
        farthestX = newX;
    }
}

// ===================== COLISÕES =====================
function checkCollision(p,e){ return p.x<e.x+e.size && p.x+p.w>e.x && p.y<e.y+e.size && p.y+p.h>e.y; }
function handleCollisions(){
    enemies.forEach(enemy=>{
        if(enemy.alive){
            if((keys.attack || player.attackCooldown>0) && player.x < enemy.x && enemy.x < player.x + player.w + 64 && Math.abs(player.y - enemy.y)<256){
                enemy.alive=false; player.score++;
                for(let i=0;i<24;i++) particles.push(new Particle(enemy.x+128,enemy.y+128,"#FFFFFF",16));
            } else if(checkCollision(player,enemy)){
                player.lives--; enemy.alive=false;
                for(let i=0;i<24;i++) particles.push(new Particle(enemy.x+128,enemy.y+128,"#FF0000",16));
                if(player.lives<=0) gameOver=true;
            }
        }
    });
    enemies = enemies.filter(e=>e.alive || e.x+e.size>cameraX-500);
}

// ===================== HUD =====================
function drawHUD(){
    for(let i=0;i<player.lives;i++){ ctx.fillStyle="red"; ctx.fillRect(20+i*48,20,40,40);}
    ctx.fillStyle="#fff"; ctx.font="32px Courier New"; ctx.fillText(`Score: ${player.score}`,20,80);
    ctx.fillText(`Fase: ${currentPhase}`,20,120);
}

// ===================== GAMEOVER =====================
function drawGameOver(){
    ctx.fillStyle="rgba(0,0,0,0.7)"; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="white"; ctx.font="64px Courier New"; ctx.fillText("GAME OVER",canvas.width/2-200,canvas.height/2-40);
    ctx.font="32px Courier New"; ctx.fillText("Toque ou Enter para reiniciar",canvas.width/2-200,canvas.height/2+40);
}

function resetGame(){ 
    player=new Player(); 
    enemies=[new Enemy(800,0),new Enemy(1600,1)]; 
    particles=[]; 
    cameraX=0;
    gameOver=false; 
    currentPhase=1;
}

// ===================== LOOP =====================
function gameLoop(){
    // Céu gradiente
    let grad = ctx.createLinearGradient(0,0,0,groundLevel);
    grad.addColorStop(0,"#0A0A1F");
    grad.addColorStop(1,"#0D0D2B");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,canvas.width,groundLevel);

    drawMoon();
    backgrounds.forEach(bg=>{ bg.update(); bg.draw(); });

    // Chão pixelado rochoso
    for(let y=groundLevel; y<canvas.height; y+=8){
        for(let x=0; x<canvas.width; x+=8){
            let shade = Math.random()<0.3 ? "#2B2B2B" : "#1F1F1F";
            ctx.fillStyle = shade;
            ctx.fillRect(x,y,8,8);
        }
    }

    if(gameStarted){
        if(!gameOver){
            player.update();
            enemies.forEach(e=>{ e.speed=Math.min(2+player.score*0.1,6); e.update(); });
            handleCollisions();
            autoSpawnEnemies();
            player.draw();
            enemies.forEach(e=>e.draw());
            particles.forEach(p=>{ p.update(); p.draw(); });
            particles = particles.filter(p=>p.alpha>0);
            drawHUD();
            cameraX = player.x - 400;
        } else drawGameOver();
    }

    requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
